package compiler488.codegen;

import compiler488.runtime.Machine;

import javax.crypto.Mac;
import java.util.ArrayList;

/**
 * Created by isthisnagee on 4/3/17.
 */
public class MachineUtils {
    public static int programOffset = 0;
    /**
     * Get the number of lines generated by this sequence of instructions
     * @param instruction
     */
    public static int numLines(ArrayList<Instruction> instruction) {
        int lines = 0;
        for (Instruction inst: instruction) {
            // add the number of args, then the code itself
            lines += inst.getArgs().size() + 1;
        }
        return lines;
    }

    /**
     * Return machine code for  `a opSymbol b`
     * @param a Instructions for the left operation
     * @param b Instructions for the right operation
     * @param opSymbol the operation symbol, one of +,-,*,/,<,<=,>,>=,=,!=,and,or
     * @return
     */
    public static ArrayList<Instruction> applyOperator(ArrayList<Instruction> a, ArrayList<Instruction> b, String opSymbol) {
        ArrayList<Instruction> ordered_instructions = new ArrayList<>();
        switch (opSymbol) {
            case "+":
                ordered_instructions.addAll(a);
                ordered_instructions.addAll(b);
                ordered_instructions.add(new Instruction(Machine.ADD));
                break;
            case "-":
                ordered_instructions.addAll(a);
                ordered_instructions.addAll(b);
                ordered_instructions.add(new Instruction(Machine.SUB));
                break;
            case "*":
                ordered_instructions.addAll(a);
                ordered_instructions.addAll(b);
                ordered_instructions.add(new Instruction(Machine.MUL));
                break;
            case "/":
                ordered_instructions.addAll(a);
                ordered_instructions.addAll(b);
                ordered_instructions.add(new Instruction(Machine.DIV));
                break;
            case ">":
                ordered_instructions.addAll(b);
                ordered_instructions.addAll(a);
                ordered_instructions.add(new Instruction(Machine.LT));
                break;
            case ">=":
                ordered_instructions.addAll(a);
                ordered_instructions.addAll(b);
                ordered_instructions.add(new Instruction(Machine.LT));
                ordered_instructions.addAll(generateNegation());
                break;
            case "<":
                ordered_instructions.addAll(a);
                ordered_instructions.addAll(b);
                ordered_instructions.add(new Instruction(Machine.LT));
                break;
            case "<=":
                ordered_instructions.addAll(b);
                ordered_instructions.addAll(a);
                ordered_instructions.add(new Instruction(Machine.LT));
                ordered_instructions.addAll(generateNegation());
                break;
            case "!=":
                ordered_instructions.addAll(a);
                ordered_instructions.addAll(b);
                ordered_instructions.add(new Instruction(Machine.EQ));
                ordered_instructions.addAll(generateNegation());
                break;
            case "and":
                ordered_instructions.addAll(a);
                ordered_instructions.addAll(generateNegation());
                ordered_instructions.addAll(b);
                ordered_instructions.addAll(generateNegation());
                ordered_instructions.add(new Instruction(Machine.OR));
                ordered_instructions.addAll(generateNegation());
                break;
            case "or":
                ordered_instructions.addAll(a);
                ordered_instructions.addAll(b);
                ordered_instructions.add(new Instruction(Machine.OR));
                break;
            case "=":
                break;
        }
        MachineUtils.programOffset++;
        return ordered_instructions;
    }

    public static ArrayList<Instruction> generateNegation() {
        ArrayList<Instruction> negation = new ArrayList<>();
        negation.add(new Instruction(Machine.PUSH, 1));
        negation.add(new Instruction(Machine.SUB));
        negation.add(new Instruction(Machine.NEG));
        MachineUtils.programOffset += numLines(negation);
        return negation;
    }


    public static ArrayList<Instruction> ifThenElse(ArrayList<Instruction> conditionInstructions, ArrayList<Instruction> trueBlock, ArrayList<Instruction> falseBlock) {
        ArrayList<Instruction> output = new ArrayList<>();

        // 6 = 2 + 1 + 2 + 1 = (push falseLineStart) bf (push exitLine) br
        MachineUtils.programOffset += 6;
        int offset = MachineUtils.programOffset;

        int falseLines = MachineUtils.numLines(falseBlock);




		/* TODO: might need a -1 */
        int falseLineStart = offset - falseLines;
        int exitLine = offset;

		/*
		 codegen(condition)
		 PUSH <else start>
		 BF
		 codegen(trueblock)
		 PUSH <exit line>
		 BR (exit)
		 codegen(falseblock)
		 // exit line num
		 */
        output.addAll(conditionInstructions);
        output.add(new Instruction(Machine.PUSH, falseLineStart));
        output.add(new Instruction(Machine.BF));

        output.addAll(trueBlock);
        output.add(new Instruction(Machine.PUSH, exitLine));
        output.add(new Instruction(Machine.BR));

        output.addAll(falseBlock);

        return output;
    }

    public static ArrayList<Instruction> ifThen(ArrayList<Instruction> conditionInstructions, ArrayList<Instruction> trueBlock) {
        ArrayList<Instruction> output = new ArrayList<>();
        output.addAll(conditionInstructions);

        MachineUtils.programOffset += 3;
        output.add(new Instruction(Machine.PUSH, MachineUtils.programOffset));
        output.add(new Instruction(Machine.BF));
        output.addAll(trueBlock);
        return output;
    }
}
