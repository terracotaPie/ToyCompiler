package compiler488.codegen;

import compiler488.runtime.Machine;

import javax.crypto.Mac;
import java.util.ArrayList;

/**
 * Created by isthisnagee on 4/3/17.
 */
public class MachineUtils {
    /**
     * Get the number of lines generated by this sequence of instructions
     * @param instruction
     */
    public static int numLines(ArrayList<Instruction> instruction) {
       return instruction.size();
    }

    /**
     * Return a check for `a > b`
     * @param a
     * @param b
     * @return
     */
    public ArrayList<Instruction> MachineGT(ArrayList<Instruction> a, ArrayList<Instruction> b) {
        ArrayList<Instruction> result = new ArrayList<>();
        result.addAll(b);
        result.addAll(a);
        result.add(new Instruction(Machine.LT));
        return result;
    }

    public static ArrayList<Instruction> applyOperator(ArrayList<Instruction> a, ArrayList<Instruction> b, String opSymbol) {
        ArrayList<Instruction> ordered_instructions = new ArrayList<>();
        switch (opSymbol) {
            case "+":
                ordered_instructions.addAll(a);
                ordered_instructions.addAll(b);
                ordered_instructions.add(new Instruction(Machine.ADD));
                break;
            case "-":
                ordered_instructions.addAll(a);
                ordered_instructions.addAll(b);
                ordered_instructions.add(new Instruction(Machine.SUB));
                break;
            case "*":
                ordered_instructions.addAll(a);
                ordered_instructions.addAll(b);
                ordered_instructions.add(new Instruction(Machine.MUL));
                break;
            case "/":
                ordered_instructions.addAll(a);
                ordered_instructions.addAll(b);
                ordered_instructions.add(new Instruction(Machine.DIV));
                break;
            case ">":
                ordered_instructions.addAll(b);
                ordered_instructions.addAll(a);
                ordered_instructions.add(new Instruction(Machine.LT));
                break;
            case ">=":
                ordered_instructions.addAll(a);
                ordered_instructions.addAll(b);
                ordered_instructions.add(new Instruction(Machine.LT));
                ordered_instructions.addAll(generateNegation());
                break;
            case "<":
                ordered_instructions.addAll(a);
                ordered_instructions.addAll(b);
                ordered_instructions.add(new Instruction(Machine.LT));
                break;
            case "<=":
                ordered_instructions.addAll(b);
                ordered_instructions.addAll(a);
                ordered_instructions.add(new Instruction(Machine.LT));
                ordered_instructions.addAll(generateNegation());
                break;
            case "!=":
                ordered_instructions.addAll(a);
                ordered_instructions.addAll(b);
                ordered_instructions.add(new Instruction(Machine.EQ));
                ordered_instructions.addAll(generateNegation());
                break;
            case "and":
                ordered_instructions.addAll(a);
                ordered_instructions.addAll(generateNegation());
                ordered_instructions.addAll(b);
                ordered_instructions.addAll(generateNegation());
                ordered_instructions.add(new Instruction(Machine.OR));
                break;
            case "or":
                ordered_instructions.addAll(a);
                ordered_instructions.addAll(b);
                ordered_instructions.add(new Instruction(Machine.OR));
                break;
            case "=":
                break;
        }
        return ordered_instructions;
    }

    public static ArrayList<Instruction> generateNegation() {
        ArrayList<Instruction> negation = new ArrayList<>();
        negation.add(new Instruction(Machine.PUSH, 1));
        negation.add(new Instruction(Machine.SUB));
        negation.add(new Instruction(Machine.NEG));
        return negation;
    }


    /**
     * Return instructinos for `a >= b`
     * @param a
     * @param b
     * @return
     */
    public static ArrayList<Instruction> MachineGTE(ArrayList<Instruction> a, ArrayList<Instruction> b) {
        return new ArrayList<>();
    }

    /**
     * Return instructinos for `a <= b`
     * @param a
     * @param b
     * @return
     */
    public static ArrayList<Instruction> MachineLTE(ArrayList<Instruction> a, ArrayList<Instruction> b) {
        return new ArrayList<>();
    }

    public static ArrayList<Instruction> ifThenElse(ArrayList<Instruction> conditionInstructions, ArrayList<Instruction> trueBlock, ArrayList<Instruction> falseBlock) {
        ArrayList<Instruction> output = new ArrayList<>();

        int lastConditionInst = conditionInstructions.size() - 1;
        int offset = conditionInstructions.get(lastConditionInst).getLineNumber();

        int breakLines = 2;
        int trueLines = MachineUtils.numLines(trueBlock);
        int falseLines = MachineUtils.numLines(falseBlock);

		/* TODO: might need a -1 */
        int trueLineStart = offset + breakLines;
        int falseLineStart = trueLineStart + trueLines + breakLines;
        int exitLine = falseLineStart + falseLines;

		/*
		 codegen(condition)
		 PUSH <else start>
		 BF
		 codegen(trueblock)
		 PUSH <exit line>
		 BR (exit)
		 codegen(falseblock)
		 // exit line num
		 */
        output.addAll(conditionInstructions);
        output.add(new Instruction(Machine.PUSH, falseLineStart));
        output.add(new Instruction(Machine.BF));

        output.addAll(trueBlock);
        output.add(new Instruction(Machine.PUSH, exitLine));
        output.add(new Instruction(Machine.BR));

        output.addAll(falseBlock);

		/* jump to true, and true */

        return output;
    }
}
