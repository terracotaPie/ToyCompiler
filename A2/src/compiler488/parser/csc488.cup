// Package and import specifications section.

package compiler488.parser;

import java_cup.runtime.*;		// Must always import this.

/* User code components 1: action code components.
 * Code to be used inside the actions triggered when productions are matched.
 * If any common code is needed for more than one action , put it here.
 */
// action code {:
// your code goes here
//:};

/* User code components 2: parser code components. 
 * Modifications to the default generated parser
 */
parser code {:

	String lastError;
	
    /* Override the report_error method so it will display the line and
     * column of where the error occurred in the input as well as the
     * reason for the error which is passed into the method in the
     * String 'message'.
     */
    public void report_error(String message, Object info)
	{
	String st =  "Error";
   
        if (info instanceof java_cup.runtime.Symbol)
	    {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);

	    /* s.left is supposed to hold the line number of the error.
	     * s.right is supposed to hold the column number.
	     */
   
            if (s.left >= 0)				// Check line number.
		{
                st += " in line " + (s.left + 1);
                if (s.right >= 0)			// Check column number.
                    st += ", column " + (s.right + 1);
		}
	    }
	    st += ": " + message;
        System.err.println (st);
        lastError = st;
	}
   
    // Override the report_fatal_error method to use the report_error method.
    public void report_fatal_error (String message, Object info) throws Exception
	{
        report_error (message, info);
        throw new Exception (lastError);
	}
   
   // version string for printing version in Main
   public static final String version =
     "Winter 2017" ;

:};

/* User code components 3: initialization code.
 * If you want some code to be executed before the parser asks for the first
 * token, add it here.
 */
init with {:
:};

/* User code components 4: scanner specification code.
 * If you need to override the way the parser asks the scanner for the
 * next token, put your preferred method here.  Uncomment the line following
 * this comment, replace the line after that with your code, and uncomment
 * the line after that.
 */
// scan with {:
// your code goes here
// :};

/* Symbol lists section.
 * The names of terminals and non-terminals are not allowed to be CUP
 * reserved words.  These include "code", "action", "parser", "terminal",
 * "non", "nonterminal", "init", "scan", "with", "start", "precedence",
 * "left", "right", "nonassoc", "import", and "package".
 */

// DEFINITIONS for CSC488S Source Language  Winter  2016/2017 

// Terminals returned by the scanner with no value attached.  
terminal	AND,	OR,	NOT,	TRUE,	FALSE	;
terminal 	BOOLEAN,INTEGER,FUNCTION,PROCEDURE	;
terminal	DO,	ELSE,	EXIT,   IF	;
terminal	READ, 	REPEAT,	RETURN,	NEWLINE,THEN,	UNTIL	;
terminal	VAR,	WHEN,	WHILE,	WITHX,	WRITE 	;

// Special-character terminals, no value attached
terminal	L_PAREN	,R_PAREN,L_SQUARE, R_SQUARE, L_CURLEY, R_CURLEY	;
terminal	EQUAL,	GREATER,LESS,	COMMA,  DOT, QUESTION, COLON	;
terminal	PLUS,	MINUS,	TIMES,  DIVIDE	;

// Terminals returned by the scanner with a value.
terminal String  IDENT	;
terminal Integer INTCONST	;
terminal String  TEXTCONST	;

// Non-terminals that have no value.
// nonterminal xxx

nonterminal	program 	;

// Non-terminals that have a value.
// nonterminal type  nameList ;

// PLEASE NOTE: your grammar can not use the 'precedence'
// feature of java-cup. The lines below should remain
// commented out.
//
//precedence right PLUS, MINUS;
//precedence right TIMES, DIVIDE;		// Higher precedence.

// The grammar section.

// This specifies the initial symbol of the grammar.
start with program;

/* Notice that sometimes the action must be inside the production rule,
 * not after it.  This is a subtle yet significant difference from YACC.
 * This is because the CUP parser is looking ahead one token.  It ALWAYS
 * reads one more token before it will act on the production.
 */


/*  YOUR CLEVERLY CRAFTED cup GRAMMAR FOR THE CSC488S SOURCE LANGUAGE
 *
 *  GOES HERE
 */
 
program		::=	;



program: scope % main program
statement: variable ’:’ ’=’ expression , % assignment
’if’ expression ’then’ statement , % conditional statement
’if’ expression ’then’ statement ’else’ statement ,
’while’ expression ’do’ statement , % loop while expression is true
’repeat’ statement ’until’ expression , % loop until expression is true
’exit’ , % exit from containing loop
’exit’ integer , % exit from integer loops
’exit’ ’when’ expression , % exit from containing loop
% when expression is true
’exit’ integer ’when’ expression , % exit from integer loops
% when expression is true
’return’ ’with’ expression , % return from function
’return’ , % return from a procedure
’write’ output , % print to standard output
’read’ input , % input from standard input
procedurename , % call procedure
procedurename ’(’ arguments ’)’ ,
scope , % embedded scope
statement statement % sequence of statements
declaration: ’var’ variablenames ’:’ type , % declare variables
’function’ functionname ’:’ type scope , % declare function
’function’ functionname ’(’ parameters ’)’ ’:’ type scope ,
’procedure’ procedurename scope , % declare procedure
’procedure’ procedurename ’(’ parameters ’)’ scope ,
declaration declaration % sequence of declarations
variablenames: variablename , % declare scalar variable
variablename ’[’ integer ’]’ , % declare one dimensional array
% bounds 1 .. integer inclusive
variablename ’[’ bound ’.’ ’.’ bound ’]’ , % declare one-dimensional array
% bounds integer .. integer inclusive
variablenames ’,’ variablenames % declare multiple variables
bound integer , % positive integer bound
’-’ integer % negative integer bound
scope ’{’ declaration statement ’}’ , % define new scope
’{’ statement ’}’ ,
’{’ ’}’ % empty scope
1
output: expression , % integer expression to be printed
text , % string constant to be printed
’newline’ , % skip to new line
output ’,’ output % output sequence
input: variable , % input to this integer variable
input ’,’ input % input sequence
type: ’Integer’ , % integer type
’Boolean’ % Boolean type
arguments: expression , % actual parameter expression
arguments ’,’ arguments % actual parameter sequence
parameters: parametername ’:’ type , % declare formal parameter
parameters ’,’ parameters % formal parameter sequence
variable: variablename , % reference to scalar variable
arrayname ’[’ expression ’]’ % reference to array element
expression: integer , % integer literal constant
’-’ expression , % unary minus
expression ’+’ expression , % addition
expression ’-’ expression , % subtraction
expression ’*’ expression , % multiplication
expression ’/’ expression , % division
’true’ , % Boolean constant true
’false’ , % Boolean constant false
’not’ expression , % Boolean not
expression ’and’ expression , % Boolean and
expression ’or’ expression , % Boolean or
expression ’=’ expression , % equality comparison
expression ’not’ ’=’ expression , % inequality comparison
expression ’<’ expression , % less than comparison
expression ’<’ ’=’ expression , % less than or equal comparison
expression ’>’ expression , % greater than comparison
expression ’>’ ’=’ expression , % greater than or equal comparison
’(’ expression ’)’ ,
’(’ expression ’?’ expression ’:’ expression ’)’ , % conditional expression
variable , % reference to variable
functionname , % call of a function
functionname ’(’ arguments ’)’ ,
parametername % reference to a parameter
variablename: identifier
arrayname: identifier
functionname: identifier
parametername: identifier
procedurename: identifier
