\section{Statements}
\subsection{Assignment}

We load the address at which we wish to store the value and then push the value
we want to assign to the stack. If the value is the result of some operation, 
(e.g.: a := 1 + 2)we perform those now to arrive at the result. Thus the top two 
elements of the stack will be the value and address, so we use STORE to assign.

\begin{code}[Assignment]
// x := 1
ADDR <@x> <#x>
PUSH 1
STORE
\end{code}

\subsection{If}

We generate the machine code for the predicate and both true and false blocks.
After evaluating the condition, we branch to the appropriate block (e.g.: if true,
BF will not branch, we execute the true block, then branch to the end).

\begin{code}[IfStatement]
codegen(condition)      // result will be top of stack after this
PUSH <@else>
BF   
codegen(true_block)             
PUSH <@end_line> 
BR           
codegen(false_block)    // else_line
...                     // end_line
\end{code}

\subsection{While and Repeat}



\subsection{Returns}

When returning we store any return value at address 0 in that level, and then
branch to the end.

\begin{code}[IfStatement]
ADDR ll 0
PUSH ret_val
STORE
PUSH end_line
BR
\end{code}


\subsection{Reading and Writing}

To write a string we push it's characters to the stack in reverse order and follow
this by one PRINTC for every character in the string. To write an integer, we push
the integer and follow this with a PRINTI command.

\begin{code}[Writing]
// write "fun"
PUSH "n"
PUSH "u"
PUSH "f"
PRINTC
PRINTC
PRINTC
\end{code}

To read a character/integer, we perform a READC/READI and then get an address to 
store this data and call store on the aforementioned values.

\begin{code}[Writing]
READI
ADDR ll addr
STORE
\end{code}
