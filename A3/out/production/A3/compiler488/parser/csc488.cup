 //  Date: 2017/02/01 21:56:02
 // Package and import specifications section.

package compiler488.parser;

import java_cup.runtime.*;  // Must always import this.
import compiler488.ast.*;
import compiler488.ast.decl.*;
import compiler488.ast.stmt.*;
import compiler488.ast.expn.*;

/* User code components 1: action code components.
 * Code to be used inside the actions triggered when productions are matched.
 * If any common code is needed for more than one action , put it here.
 */
// action code {:
// your code goes HERE
//:};

/* User code components 2: parser code components. 
 * Modifications to the default generated parser
 */
parser code {:

String lastError;

    /** Override the report_error method so it will display the line and
     * column of where the error occurred in the input as well as the
     * reason for the error which is passed into the method in the
     * String 'message'.
     * @param message error message to print
     * @param info    symbol containing line/column numbers
     */
    public void report_error(String message, Object info)
  {
  String st = "Error";

        if (info instanceof java_cup.runtime.Symbol)
      {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);

      /* s.left is supposed to hold the line number of the error.
       * s.right is supposed to hold the column number.
             * If either is < 0 the parser may have run off the end of the program
             * and a Syntax Error message without line number may be printed.
       */

            if (s.left >= 0)  // Check line number.
    {
                st += " in line " + (s.left + 1);
                if (s.right >= 0)  // Check column number.
                    st += ", column " + (s.right + 1);
    }
            else
               st += " at end of input " ;
           }
      st += ": " + message;
        System.err.println (st);
        lastError = st;
  }

    /** Override the report_fatal_error method to use the report_error method. */
    /** @throws SyntaxErrorException           */
    public void report_fatal_error (String message, Object info) throws SyntaxErrorException
  {
        report_error (message, info);
/*       throw new SyntaxErrorException (lastError); */
  }

   /** version string for printing version in Main */
   public static final String version =
     " $Revision: 1.7 $ $Date: 2012/02/08 21:56:02 $Author: dw $" ;

:};

/* User code components 3: initialization code.
 * If you want some code to be executed before the parser asks for the first
 * token, add it here.
 */
init with {:
:};

/* User code components 4: scanner specification code.
 * If you need to override the way the parser asks the scanner for the
 * next token, put your preferred method here. Uncomment the line following
 * this comment, replace the line after that with your code, and uncomment
 * the line after that.
 */
// scan with {:
// your code goes here
// :};

/* Symbol lists section.
 * The names of terminals and non-terminals are not allowed to be CUP
 * reserved words. These include "code", "action", "parser", "terminal",
 * "non", "nonterminal", "init", "scan", "with", "start", "precedence",
 * "left", "right", "nonassoc", "import", and "package".
 */

// DEFINITIONS for CSC488S Source Language Winter 2011/2012

// Terminals returned by the scanner with no value attached.
terminal AND, OR, NOT, TRUE, FALSE ;
terminal  BOOLEAN,INTEGER,FUNCTION,PROCEDURE ;
terminal DO, ELSE, EXIT,  IF ;
terminal READ,  REPEAT, RETURN, NEWLINE,THEN, UNTIL ;
terminal VAR, WHEN, WHILE, WITHX, WRITE  ;

// Special-character terminals, no value attached
terminal L_PAREN ,R_PAREN,L_SQUARE, R_SQUARE, L_CURLEY, R_CURLEY ;
terminal EQUAL, GREATER,LESS, COMMA, DOT, QUESTION, COLON ;
terminal PLUS, MINUS, TIMES, DIVIDE ;

// Terminals returned by the scanner with a value.
terminal String IDENT ;
terminal Integer INTCONST ;
terminal String TEXTCONST ;

// Non-terminals that have no value.
// nonterminal xxx
// var x, y: Integer

// Types:
nonterminal program;
nonterminal compiler488.ast.stmt.Stmt statement;
nonterminal compiler488.ast.decl.Declaration declaration;
nonterminal compiler488.ast.stmt.Scope scope;
nonterminal ASTList<compiler488.ast.stmt.Stmt> statements;
nonterminal ASTList<compiler488.ast.decl.Declaration> declarations;
nonterminal Stmt matchedStatement;
nonterminal Stmt unmatchedStatement;
nonterminal ASTList<DeclarationPart> variablenames;
// TODO: assign type
nonterminal output;
nonterminal compiler488.ast.type.Type type;
// TODO: assign type
nonterminal arguments;
// TODO: assign type
nonterminal parameters;
// TODO: should be IdentExpn?
nonterminal compiler488.ast.expn.Expn variable;
nonterminal compiler488.ast.expn.Expn expression;
nonterminal compiler488.ast.decl.DeclarationPart variablename;
// TODO: assign type
nonterminal inputs;
// TODO: assign type
nonterminal outputs;
nonterminal Integer bound;
// TODO: assign type
nonterminal procedureCall;
// TODO: assign type
nonterminal parameter;
// TODO: assign type
nonterminal conjunction;
// TODO: assign type
nonterminal negation;
nonterminal compiler488.ast.expn.CompareExpn compareExpn;
nonterminal compiler488.ast.expn.BinaryExpn arithExpn;
// TODO: assign type
nonterminal term;
// TODO: assign type
nonterminal factor;
// TODO: assign type
// constant, variable, f (a1,..,an), (exp), (exp ? exp : exp)
nonterminal Expn primary;
// TODO: assign type
nonterminal ConstExpn constant;
// Non-terminals that have a value.
// nonterminal type nameList ;

// PLEASE NOTE: your grammar can not use the 'precedence'
// feature of java-cup. The lines below should remain
// commented.
//
//precedence left PLUS, MINUS;
//precedence left TIMES, DIVIDE;  // Higher precedence.
precedence  left ELSE ;

 // The grammar section.

 // This specifies the initial symbol of the grammar.
start with program;

/* Notice that sometimes the action must be inside the production rule,
 * not after it. This is a subtle yet significant difference from YACC.
 * This is because the CUP parser is looking ahead one token. It ALWAYS
 * reads one more token before it will act on the production.
 */

program
  ::= scope
      {:
        System.out.println("creating scope");
        RESULT = new compiler488.ast.stmt.Program();
      :}
    ;

scope
  ::= L_CURLEY declarations:dcs statements:sts R_CURLEY
      {:
        RESULT = new compiler488.ast.stmt.Scope();
        RESULT.setDeclarations(dcs);
        RESULT.setStatements(sts);
      :}
    | L_CURLEY statements:sts R_CURLEY
      {:
        RESULT = new compiler488.ast.stmt.Scope();
        RESULT.setStatements(sts);
      :}
    | L_CURLEY R_CURLEY
      {:
        // TODO does nothing?
      :}
    ;

statements
  ::= statement:s
      {:
        RESULT = new ASTList<compiler488.ast.stmt.Stmt>();
        RESULT.addLast(s);
      :}
    | statements:ss statement:s
      {:
        RESULT = ss;
        RESULT.addLast(s);
      :}
    ;

declarations
  ::= declaration:d
      {:
        RESULT = new ASTList<compiler488.ast.decl.Declaration>();
        RESULT.addLast(d);
      :}
    | declarations:ds declaration:d
      {:
        RESULT = ds;
        RESULT.addLast(d);
      :}
  ;

statement
  ::= matchedStatement
    | unmatchedStatement
    ;

matchedStatement
  ::= variable:var COLON EQUAL expression:exp
      {:
        System.out.println("assigning a variable");
        RESULT = new compiler488.ast.stmt.AssignStmt();
        // check that var and exp have the same type
        ((AssignStmt)RESULT).setLval((compiler488.ast.expn.IdentExpn)var);
        ((AssignStmt)RESULT).setRval((compiler488.ast.expn.Expn)exp);
      :}
    | IF expression:exp THEN matchedStatement:s1 ELSE matchedStatement:s2
      {:
        RESULT = new IfStmt();
        ((IfStmt)RESULT).setCondition(exp);
        ((IfStmt)RESULT).setWhenTrue(s1);
        ((IfStmt)RESULT).setWhenFalse(s2);
      :}
    | WHILE expression:expn DO statement:stmt
      {:
        RESULT = new WhileDoStmt();
        ((WhileDoStmt)RESULT).setExpn(expn);
        ((WhileDoStmt)RESULT).setBody(stmt);
      :}
    | REPEAT statement UNTIL expression
    | EXIT
    | EXIT INTCONST
    | EXIT WHEN expression
    | EXIT INTCONST WHEN expression
    | RETURN WITHX expression
    | RETURN
    | WRITE outputs
    | READ inputs
    | procedureCall
    | scope
    ;

unmatchedStatement
  ::= IF expression THEN statement
    | IF expression THEN matchedStatement ELSE unmatchedStatement
    ;

procedureCall
  ::= IDENT  // call procedure with no parameters
    | IDENT L_PAREN arguments R_PAREN  // call procedure with parameters
    ;

declaration
  ::= VAR variablenames:vn COLON type:t  // declare scalar/array variables
      {:
        RESULT = new MultiDeclarations();
        ((MultiDeclarations)RESULT).setElements(vn);
        RESULT.setType(t);
      :}
    | FUNCTION IDENT COLON type scope  // declare function
    | FUNCTION IDENT L_PAREN parameters R_PAREN COLON type scope
    | PROCEDURE IDENT scope  // declare procedure
    | PROCEDURE IDENT L_PAREN parameters R_PAREN scope
    ;

variablenames
  ::= variablename:v  // list of variables being declared
        {:
           RESULT = new ASTList<DeclarationPart>();
           RESULT.addLast(v);
        :}
    | variablenames:vn COMMA variablename:v
      {:
        RESULT = vn;
        RESULT.addLast(v);
      :}
    ;

variablename
  ::= IDENT:n  // scalar variable
      {:
        RESULT = new DeclarationPart();
        RESULT.setName(n);
      :}
    | IDENT:n L_SQUARE INTCONST:s R_SQUARE  // array variable with upper bound
      {:
        RESULT = new ArrayDeclPart();
        RESULT.setName(n);
        ((ArrayDeclPart)RESULT).setSize(s);
        ((ArrayDeclPart)RESULT).setLowerBoundary(0);
        ((ArrayDeclPart)RESULT).setUpperBoundary(s);
      :}
    | IDENT:n L_SQUARE bound:l DOT DOT bound:u R_SQUARE  // array variable with upper/lower bounds
      {:
        RESULT = new ArrayDeclPart();
        RESULT.setName(n);
        ((ArrayDeclPart)RESULT).setSize(l - u + 1);
        ((ArrayDeclPart)RESULT).setLowerBoundary(l);
        ((ArrayDeclPart)RESULT).setUpperBoundary(u);
      :}
    ;

bound
  ::= INTCONST:i  // positive array bound
      {:
        RESULT = i;
      :}
    | MINUS INTCONST:i  // negative array bound
      {:
        RESULT = -i;
      :}
    ;

type
  ::= INTEGER  // integer type
      {:
        System.out.println("Creating an integer");
        RESULT = new compiler488.ast.type.IntegerType();
      :}
    | BOOLEAN  // boolean type
      {:
        RESULT = new compiler488.ast.type.BooleanType();
      :}
    ;

outputs
  ::= output  // list of output expressions
    | outputs COMMA output
    ;

output
  ::= expression  // integer expression
    | TEXTCONST  // text constant
    | NEWLINE  // newline constant
    ;

inputs
  ::= variable  // list of variables being read into
    | inputs COMMA variable
    ;

arguments
  ::= expression  // list of function/procedure arguments
    | arguments COMMA expression
    ;

parameters
  ::= parameter  // list of function/procedure formal parameters
    | parameters COMMA parameter
    ;

parameter
  ::= IDENT COLON type  // declare one parameter
    ;

expression
  ::= conjunction  // disjunctions, associate left-to-right
    | expression OR conjunction
    ;

conjunction
  ::= negation  // conjunctions, associate left-to-right
    | conjunction AND negation
    ;

negation
  ::= compareExpn  // negations
    | NOT negation
    ;

compareExpn
  ::= arithExpn
    | arithExpn EQUAL arithExpn
    | arithExpn NOT EQUAL arithExpn
    | arithExpn LESS arithExpn
    | arithExpn LESS EQUAL arithExpn
    | arithExpn GREATER arithExpn
    | arithExpn GREATER EQUAL arithExpn
    ;


arithExpn
  ::= term  // expressions, associate + , - left-to-right
    | arithExpn PLUS term
    | arithExpn MINUS term
    ;

term
  ::= factor  // terms, associate * , /  left-to-right
    | term TIMES factor
    | term DIVIDE factor
    ;

factor
  ::= primary:p  // unary minus
      {:
          RESULT = p;
      :}
    | MINUS factor
    ;

// an Expn
primary
  ::= constant:c  // integer or boolean constant
      {:
        RESULT = (ConstExpn)c;
      :}
    | variable  // scalar, array variable or function call
    | IDENT L_PAREN arguments R_PAREN  // function call
    | L_PAREN expression R_PAREN  // parenthesized expression
    | L_PAREN expression QUESTION expression COLON expression R_PAREN
    ;

// an Expn
constant
  ::= INTCONST:i  // integer constant
      {:
        RESULT = new IntConstExpn();
        ((IntConstExpn)RESULT).setValue(i);
      :}
    | TRUE  // constant true
      {:
        RESULT = new BoolConstExpn();
        ((BoolConstExpn)RESULT).setValue(true);
      :}
    | FALSE  // constant false
      {:
        RESULT = new BoolConstExpn();
        ((BoolConstExpn)RESULT).setValue(false);
      :}
    ;

variable
  ::= IDENT:name  // scalar variable or function call
      {:
        RESULT = new IdentExpn();
        ((IdentExpn)RESULT).setIdent(name);
      :}
    | IDENT:aName L_SQUARE expression:i R_SQUARE  // element of an array
      {:
        RESULT = new SubsExpn();
        ((SubsExpn)RESULT).setVariable((String)aName);
        ((SubsExpn)RESULT).setOperand((Expn)i);
      :}
    ;
