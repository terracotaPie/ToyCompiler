// Package and import specifications section.

package compiler488.parser;

import java_cup.runtime.*;  // Must always import this.
import compiler488.ast.*;
import compiler488.ast.decl.*;
import compiler488.ast.expn.*;
import compiler488.ast.stmt.*;
import compiler488.ast.type.*;

/* User code components 1: action code components.
 * Code to be used inside the actions triggered when productions are matched.
 * If any common code is needed for more than one action , put it here.
 */
// action code {:
// your code goes HERE
//:};

/* User code components 2: parser code components.
 * Modifications to the default generated parser
 */
parser code {:

  String lastError;

  /* Override the report_error method so it will display the line and
   * column of where the error occurred in the input as well as the
   * reason for the error which is passed into the method in the
   * String 'message'.
   * @param message error message to print
   * @param info  symbol containing line/column numbers
   */
  public void report_error(String message, Object info)
  {
  String st = "Error";

    if (info instanceof java_cup.runtime.Symbol)
    {
      java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);

    /* s.left is supposed to hold the line number of the error.
     * s.right is supposed to hold the column number.
       * If either is < 0 the parser may have run off the end of the program
       * and a Syntax Error message without line number may be printed.
     */

      if (s.left >= 0)  // Check line number.
      {
        st += " in line " + (s.left + 1);
        if (s.right >= 0)  // Check column number.
          st += ", column " + (s.right + 1);
      }
      else
         st += " at end of input ";
    }
    st += ": " + message;
    System.err.println (st);
    lastError = st;
  }

  // Override the report_fatal_error method to use the report_error method.
  /** @throws SyntaxErrorException           */
  public void report_fatal_error (String message, Object info) throws SyntaxErrorException
  {
    report_error (message, info);
    throw new SyntaxErrorException (lastError);
  }

  // version string for printing version in Main
  public static final String version = "Winter 2017";

:};

/* User code components 3: initialization code.
 * If you want some code to be executed before the parser asks for the first
 * token, add it here.
 */
init with {:
:};

/* User code components 4: scanner specification code.
 * If you need to override the way the parser asks the scanner for the
 * next token, put your preferred method here. Uncomment the line following
 * this comment, replace the line after that with your code, and uncomment
 * the line after that.
 */
// scan with {:
// your code goes here
// :};

/* Symbol lists section.
 * The names of terminals and non-terminals are not allowed to be CUP
 * reserved words. These include "code", "action", "parser", "terminal",
 * "non", "nonterminal", "init", "scan", "with", "start", "precedence",
 * "left", "right", "nonassoc", "import", and "package".
 */

// DEFINITIONS for CSC488S Source Language Winter 2017

// Terminals returned by the scanner with no value attached.
terminal AND, OR, NOT, TRUE, FALSE;
terminal  BOOLEAN,INTEGER,FUNCTION,PROCEDURE;
terminal DO, ELSE, EXIT, IF;
terminal READ, REPEAT, RETURN, NEWLINE,THEN, UNTIL;
terminal VAR, WHEN, WHILE, WITHX, WRITE;

// Special-character terminals, no value attached
terminal L_PAREN ,R_PAREN,L_SQUARE, R_SQUARE, L_CURLEY, R_CURLEY;
terminal EQUAL, GREATER,LESS, COMMA, DOT, QUESTION, COLON;
terminal PLUS, MINUS, TIMES, DIVIDE;

// Terminals returned by the scanner with a value.
terminal String IDENT;
terminal Integer INTCONST;
terminal String TEXTCONST;

// Non-terminals that have no value.
// nonterminal xxx

nonterminal Program program;
nonterminal Stmt statement;
nonterminal Declaration declaration;
nonterminal Scope scope;
nonterminal ASTList<Stmt> statements;
nonterminal ASTList<Declaration> declarations;
nonterminal Stmt matchedStatement;
nonterminal Stmt unmatchedStatement;
nonterminal ASTList<DeclarationPart> variablenames;
nonterminal output;
nonterminal Type type;
nonterminal ASTList<Expn> arguments;
nonterminal ASTList<ScalarDecl> parameters;
nonterminal Expn variable;
nonterminal Expn expression;
nonterminal DeclarationPart variablename;
nonterminal inputs;
nonterminal outputs;
nonterminal IntConstExpn bound;
nonterminal ProcedureCallStmt procedureCall;
nonterminal ScalarDecl parameter;
nonterminal Expn conjunction;
nonterminal Expn negation;
nonterminal Expn compareExpn;
nonterminal Expn arithExpn;
nonterminal Expn term;
nonterminal Expn factor;
nonterminal Expn primary;
nonterminal ConstExpn constant;

// Non-terminals that have a value.
// nonterminal type nameList;

// PLEASE NOTE: your grammar can not use the 'precedence'
// feature of java-cup. The lines below should remain
// commented out.
//
//precedence left PLUS, MINUS;
//precedence left TIMES, DIVIDE;  // Higher precedence.
precedence  left ELSE;

// The grammar section.

// This specifies the initial symbol of the grammar.
start with program;

/* Notice that sometimes the action must be inside the production rule,
 * not after it. This is a subtle yet significant difference from YACC.
 * This is because the CUP parser is looking ahead one token. It ALWAYS
 * reads one more token before it will act on the production.
 */

program
  ::= scope  // the main program
      {:
        System.out.println("Program");
        RESULT = new Program();
      :}
;

scope
  ::= L_CURLEY declarations:dcs statements:stmts R_CURLEY  // scope with declarations and statements
      {:
        System.out.println("Scope");
        RESULT = new Scope();
        ((Scope)RESULT).setStatements(stmts);
        ((Scope)RESULT).setDeclarations(dcs);
      :}
    | L_CURLEY declarations:dcs R_CURLEY  // scope with declarations and statements
      {:
        System.out.println("Scope");
        RESULT = new Scope();
        ((Scope)RESULT).setDeclarations(dcs);
      :}
    | L_CURLEY statements:stmts R_CURLEY  // scope with statments only
      {:
        RESULT = new Scope();
        ((Scope)RESULT).setStatements(stmts);
      :}
    | L_CURLEY R_CURLEY  // empty scope
      {:
        RESULT = new Scope();
      :}
;

statements
  ::= statement:s  // sequence of statements
      {:
        RESULT = new ASTList<Stmt>();
        ((ASTList<Stmt>)RESULT).addLast(s);
      :}
    | statements:stmts statement:s
      {:
        RESULT = stmts;
        RESULT.addLast(s);
      :}
;

declarations
  ::= declaration:d  // sequence of declarations
      {:
        RESULT = new ASTList<Declaration>();
        ((ASTList<Declaration>)RESULT).addLast(d);
      :}
    | declarations:ds declaration:d
      {:
        RESULT = ds;
        RESULT.addLast(d);
      :}
;

statement
  ::= matchedStatement:m
      {:
        // TODO: idk
        RESULT = m;
      :}
    | unmatchedStatement:s
      {:
        // TODO: idk
        RESULT = s;
      :}
;

matchedStatement
  ::= variable:var COLON EQUAL expression:expr  // assignment statement
      {:
        RESULT = new AssignStmt();
        ((AssignStmt)RESULT).setLval(var);
        ((AssignStmt)RESULT).setRval(expr);
      :}
    | IF expression:e THEN matchedStatement:thenStmt ELSE matchedStatement:elseStmt  // if statements
      {:
        RESULT = new IfStmt();
        ((IfStmt)RESULT).setCondition(e);
        ((IfStmt)RESULT).setWhenTrue(thenStmt);
        ((IfStmt)RESULT).setWhenFalse(elseStmt);
      :}
    | WHILE expression:exp DO statement:stmt  // while statement
      {:
        RESULT = new WhileDoStmt();
        ((WhileDoStmt)RESULT).setBody(stmt);
        ((WhileDoStmt)RESULT).setExpn(exp);
      :}
    | REPEAT statement:stmt UNTIL expression:exp  // repeat statement
      {:
        RESULT = new RepeatUntilStmt();
        ((RepeatUntilStmt)RESULT).setBody(stmt);
        ((RepeatUntilStmt)RESULT).setExpn(exp);
      :}
    | EXIT
      {:
        // TODO: check if this generates a cascading statment or a score for each exit cond
        // i.e. do i need to initialize new ExitStmt for every exit type
        RESULT = new ExitStmt();
      :}
    | EXIT INTCONST:level
      {:
        RESULT = new ExitStmt();
        ((ExitStmt)RESULT).setLevel(level);
      :}
    | EXIT WHEN expression:cond
      {:
        RESULT = new ExitStmt();
        ((ExitStmt)RESULT).setExpn(cond);
      :}
    | EXIT INTCONST:level WHEN expression:cond
      {:
        RESULT = new ExitStmt();
        ((ExitStmt)RESULT).setLevel(level);
        ((ExitStmt)RESULT).setExpn(cond);
      :}
    | RETURN WITHX expression:expn
      {:
        RESULT = new ReturnStmt();
        ((ReturnStmt)RESULT).setValue(expn);
      :}
    | RETURN
      {:
        RESULT = new ReturnStmt();
      :}
      // TODO: read/write/calls
    | WRITE outputs:out
    | READ inputs:ins
    | procedureCall:p
    | scope:s
    ;


unmatchedStatement
  ::= IF expression:e THEN statement:thenStmt
      {:
        RESULT = new IfStmt();
        ((IfStmt)RESULT).setCondition(e);
        ((IfStmt)RESULT).setWhenTrue(thenStmt);
      :}
    | IF expression:e THEN matchedStatement:thenStmt ELSE unmatchedStatement:elseStmt
      {:
        RESULT = new IfStmt();
        ((IfStmt)RESULT).setCondition(e);
        ((IfStmt)RESULT).setWhenTrue(thenStmt);
        ((IfStmt)RESULT).setWhenFalse(elseStmt);
      :}
;

procedureCall
  ::= IDENT:name  // call procedure with no parameters
      {:
        RESULT = new ProcedureCallStmt();
        ((ProcedureCallStmt)RESULT).setName(name);
      :}
    | IDENT:name L_PAREN arguments:args R_PAREN  // call procedure with parameters
      {:
        RESULT = new ProcedureCallStmt();
        ((ProcedureCallStmt)RESULT).setName(name);
        ((ProcedureCallStmt)RESULT).setArguments(args);
      :}
;

declaration
  ::= VAR variablenames:varNames COLON type:t  // declare scalar/array variables
      {:
        System.out.println("Declaration");
        System.out.println(t.toString());

        // var a,b,c : Int
        RESULT = new MultiDeclarations();
        ((MultiDeclarations)RESULT).setElements(varNames);
        ((MultiDeclarations)RESULT).setType(t);
      :}
    | FUNCTION IDENT:fname COLON type:returnType scope:s // declare function
      {:
        System.out.println("Function Name: " + fname);

        RoutineBody body = new RoutineBody();
        body.setBody(s);

        RESULT = new RoutineDecl();
        ((RoutineDecl)RESULT).setName(fname);
        ((RoutineDecl)RESULT).setType(returnType);
        ((RoutineDecl)RESULT).setRoutineBody(body);
      :}
    | FUNCTION IDENT:fname L_PAREN parameters:params R_PAREN COLON type:returnType scope:s
      {:
        System.out.println("Function w/ args Name: " + fname);

        RoutineBody body = new RoutineBody();
        body.setBody(s);
        body.setParameters(params);

        RESULT = new RoutineDecl();
        ((RoutineDecl)RESULT).setName(fname);
        ((RoutineDecl)RESULT).setType(returnType);
        ((RoutineDecl)RESULT).setRoutineBody(body);
      :}
    | PROCEDURE IDENT:pname scope:s  // declare procedure
      {:
        System.out.println("Procedure Name: " + pname);

        RoutineBody body = new RoutineBody();
        body.setBody(s);

        RESULT = new RoutineDecl();
        ((RoutineDecl)RESULT).setName(pname);
        ((RoutineDecl)RESULT).setRoutineBody(body);
      :}
    | PROCEDURE IDENT:pname L_PAREN parameters:params R_PAREN scope:s
      {:
        System.out.println("Procedure w/ args Name: " + pname);

        RoutineBody body = new RoutineBody();
        body.setBody(s);
        body.setParameters(params);

        RESULT = new RoutineDecl();
        ((RoutineDecl)RESULT).setName(pname);
        ((RoutineDecl)RESULT).setRoutineBody(body);
      :}
;

variablenames
  ::= variablename:varName  // list of variables being declared
      {:
        System.out.println("VariableName");
        RESULT = new ASTList<DeclarationPart>();
        RESULT.addLast((DeclarationPart)varName);
      :}
    | variablenames:vs COMMA variablename:v
      {:
        System.out.println("VariableNames");
        RESULT = (ASTList<DeclarationPart>)vs;
        RESULT.addLast((DeclarationPart)v);
      :}
;

variablename
  ::= IDENT:id  // scalar variable
      {:
        System.out.println("VariableName: " + id);
        RESULT = new DeclarationPart();
        ((DeclarationPart)RESULT).setName(id);
      :}
    | IDENT:id L_SQUARE INTCONST:i R_SQUARE  // array variable with upper bound
      {:
        // semantic analysis: i > 0
        RESULT = new ArrayDeclPart();
        ((ArrayDeclPart)RESULT).setName(id);
        ((ArrayDeclPart)RESULT).setLowerBoundary(0);
        ((ArrayDeclPart)RESULT).setUpperBoundary(i);
        ((ArrayDeclPart)RESULT).setSize(i);
      :}
    | IDENT:id L_SQUARE bound:upBoundExpn DOT DOT bound:lowBoundExpn R_SQUARE  // array variable with upper/lower bounds
      {:
        Integer upper = upBoundExpn.getValue();
        Integer lower = lowBoundExpn.getValue();
        Integer size = upper - lower;
        // semantic analysis: i > 0
        RESULT = new ArrayDeclPart();
        ((ArrayDeclPart)RESULT).setName(id);
        ((ArrayDeclPart)RESULT).setLowerBoundary(lower);
        ((ArrayDeclPart)RESULT).setUpperBoundary(upper);
        ((ArrayDeclPart)RESULT).setSize((size < 0) ? -size : size);
      :}
;

bound
  ::= INTCONST:i  // positive array bound
      {:
        RESULT = new IntConstExpn();
        ((IntConstExpn)RESULT).setValue(i);
      :}
    | MINUS INTCONST:i  // negative array bound
      {:
        RESULT = new IntConstExpn();
        ((IntConstExpn)RESULT).setValue(-i);
      :}
;

type
  ::= INTEGER  // integer type
      {:
        RESULT = new IntegerType();
      :}
    | BOOLEAN  // boolean type
      {:
        RESULT = new BooleanType();
      :}
;

outputs
  ::= output  // list of output expressions
    | outputs COMMA output
;

output
  ::= expression  // integer expression
    | TEXTCONST  // text constant
    | NEWLINE  // newline constant
;

inputs
  ::= variable  // list of variables being read into
    | inputs COMMA variable
;

arguments
  ::= expression:e  // list of function/procedure arguments
      {:
        RESULT = new ASTList<Expn>();
        RESULT.addLast(e);
      :}
    | arguments:es COMMA expression:e
      {:
        RESULT = es;
        RESULT.addLast(e);
      :}
;

parameters
  ::= parameter:param  // list of function/procedure formal parameters
      {:
        RESULT = new ASTList<ScalarDecl>();
        RESULT.addLast(param);
      :}
    | parameters:ps COMMA parameter:p
      {:
        RESULT = ps;
        RESULT.addLast(p);
      :}
;

parameter
  ::= IDENT:name COLON type:t  // declare one parameter
      {:
        RESULT = new ScalarDecl();
        ((ScalarDecl)RESULT).setName(name);
        ((ScalarDecl)RESULT).setType(t);
      :}
;

expression
  ::= conjunction:c  // disjunctions, associate left-to-right
      {:
        RESULT = c;
      :}
    | expression OR conjunction
;

conjunction
  ::= negation:c  // conjunctions, associate left-to-right
      {:
        RESULT = c;
      :}
    | conjunction AND negation
;

negation
  ::= compareExpn:c  // negations
      {:
        RESULT = c;
      :}
    | NOT negation
;

compareExpn
  ::= arithExpn:a  // comparisons, do not associate
      {:
        RESULT = a;
      :}
    | arithExpn EQUAL arithExpn
    |  arithExpn NOT EQUAL arithExpn
    | arithExpn LESS arithExpn
    | arithExpn LESS EQUAL arithExpn
    | arithExpn GREATER arithExpn
    | arithExpn GREATER EQUAL arithExpn
;

arithExpn
  ::= term:t  // expressions, associate + , - left-to-right
      {:
        RESULT = t;
      :}
    | arithExpn PLUS term
    | arithExpn MINUS term
;

term
  ::= factor:f  // terms, associate * , /  left-to-right
      {:
        RESULT = f;
      :}
    | term:a TIMES factor:b
      {:
        RESULT = new BinaryExpn();
        ((BinaryExpn)RESULT).setLeft(a);
        ((BinaryExpn)RESULT).setRight(b);
        ((BinaryExpn)RESULT).setOpSymbol("*");
      :}
    | term:a DIVIDE factor:b
      {:
        RESULT = new BinaryExpn();
        ((BinaryExpn)RESULT).setLeft(a);
        ((BinaryExpn)RESULT).setRight(b);
        ((BinaryExpn)RESULT).setOpSymbol("/");
      :}
;

factor
  ::= primary:p  // unary minus
      {:
        RESULT = p;
      :}
    | MINUS factor:f
      {:
        RESULT = new UnaryMinusExpn();
        ((UnaryMinusExpn)RESULT).setOperand(f);
        ((UnaryMinusExpn)RESULT).setOpSymbol("-");
      :}
;

primary
  ::= constant:c  // integer or boolean constant
      {:
        RESULT = c;
      :}
    | variable:v  // scalar, array variable or function call
      {:
        RESULT = v;
      :}
    | IDENT:name L_PAREN arguments:args R_PAREN  // function call
      {:
        RESULT = new FunctionCallExpn();
        ((FunctionCallExpn)RESULT).setIdent(name);
        ((FunctionCallExpn)RESULT).setArguments(args);
      :}
    | L_PAREN expression:e R_PAREN  // parenthesized expression
      {:
        RESULT = e;
      :}
    | L_PAREN expression:cond QUESTION expression:trueExpn COLON expression:falseExpn R_PAREN
      {:
        RESULT = new ConditionalExpn();
        ((ConditionalExpn)RESULT).setCondition(cond);
        ((ConditionalExpn)RESULT).setTrueValue(trueExpn);
        ((ConditionalExpn)RESULT).setFalseValue(falseExpn);
      :}
;

constant // type: ConstEpn
  ::= INTCONST:i  // integer constant
      {:
        RESULT = new IntConstExpn();
        ((IntConstExpn)RESULT).setValue(i);
      :}
    | TRUE  // constant true
      {:
        RESULT = new BoolConstExpn();
        ((BoolConstExpn)RESULT).setValue(true);
      :}
    | FALSE  // constant false
      {:
        RESULT = new BoolConstExpn();
        ((BoolConstExpn)RESULT).setValue(false);
      :}
;

variable
  ::= IDENT:name  // scalar variable or function call
      {:
        RESULT = new IdentExpn();
        ((IdentExpn)RESULT).setIdent(name);
      :}
    | IDENT:name L_SQUARE expression:expn R_SQUARE  // element of an array
      {:
        // semantic analysis: check operand is arith expn
        RESULT = new SubsExpn();
        ((SubsExpn)RESULT).setVariable(name);
        ((SubsExpn)RESULT).setOperand(expn);
      :}
;


