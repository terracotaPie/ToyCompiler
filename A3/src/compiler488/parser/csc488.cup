// Package and import specifications section.

package compiler488.parser;

import java_cup.runtime.*;  // Must always import this.
import compiler488.ast.*;
import compiler488.ast.decl.*;
import compiler488.ast.expn.*;
import compiler488.ast.stmt.*;
import compiler488.ast.type.*;

/* User code components 1: action code components.
 * Code to be used inside the actions triggered when productions are matched.
 * If any common code is needed for more than one action , put it here.
 */
// action code {:
// your code goes HERE
//:};

/* User code components 2: parser code components.
 * Modifications to the default generated parser
 */
parser code {:

  String lastError;

  /* Override the report_error method so it will display the line and
   * column of where the error occurred in the input as well as the
   * reason for the error which is passed into the method in the
   * String 'message'.
   * @param message error message to print
   * @param info  symbol containing line/column numbers
   */
  public void report_error(String message, Object info)
  {
  String st = "Error";

    if (info instanceof java_cup.runtime.Symbol)
    {
      java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);

    /* s.left is supposed to hold the line number of the error.
     * s.right is supposed to hold the column number.
       * If either is < 0 the parser may have run off the end of the program
       * and a Syntax Error message without line number may be printed.
     */

      if (s.left >= 0)  // Check line number.
      {
        st += " in line " + (s.left + 1);
        if (s.right >= 0)  // Check column number.
          st += ", column " + (s.right + 1);
      }
      else
         st += " at end of input ";
    }
    st += ": " + message;
    System.err.println (st);
    lastError = st;
  }

  // Override the report_fatal_error method to use the report_error method.
  /** @throws SyntaxErrorException           */
  public void report_fatal_error (String message, Object info) throws SyntaxErrorException
  {
    report_error (message, info);
    throw new SyntaxErrorException (lastError);
  }

  // version string for printing version in Main
  public static final String version = "Winter 2017";

:};

/* User code components 3: initialization code.
 * If you want some code to be executed before the parser asks for the first
 * token, add it here.
 */
init with {:
:};

/* User code components 4: scanner specification code.
 * If you need to override the way the parser asks the scanner for the
 * next token, put your preferred method here. Uncomment the line following
 * this comment, replace the line after that with your code, and uncomment
 * the line after that.
 */
// scan with {:
// your code goes here
// :};

/* Symbol lists section.
 * The names of terminals and non-terminals are not allowed to be CUP
 * reserved words. These include "code", "action", "parser", "terminal",
 * "non", "nonterminal", "init", "scan", "with", "start", "precedence",
 * "left", "right", "nonassoc", "import", and "package".
 */

// DEFINITIONS for CSC488S Source Language Winter 2017

// Terminals returned by the scanner with no value attached.
terminal AND, OR, NOT, TRUE, FALSE;
terminal  BOOLEAN,INTEGER,FUNCTION,PROCEDURE;
terminal DO, ELSE, EXIT, IF;
terminal READ, REPEAT, RETURN, NEWLINE,THEN, UNTIL;
terminal VAR, WHEN, WHILE, WITHX, WRITE;

// Special-character terminals, no value attached
terminal L_PAREN ,R_PAREN,L_SQUARE, R_SQUARE, L_CURLEY, R_CURLEY;
terminal EQUAL, GREATER,LESS, COMMA, DOT, QUESTION, COLON;
terminal PLUS, MINUS, TIMES, DIVIDE;

// Terminals returned by the scanner with a value.
terminal String IDENT;
terminal Integer INTCONST;
terminal String TEXTCONST;

// Non-terminals that have no value.
// nonterminal xxx

nonterminal Program program;
nonterminal Stmt statement;
nonterminal Declaration declaration;
nonterminal Scope scope;
nonterminal ASTList<Stmt> statements;
nonterminal ASTList<Declaration> declarations;
nonterminal matchedStatement;
nonterminal unmatchedStatement;
nonterminal ASTList<DeclarationPart> variablenames;
nonterminal output;
nonterminal Type type;
nonterminal arguments;
nonterminal ASTList<ScalarDecl> parameters;
nonterminal variable;
nonterminal expression;
nonterminal DeclarationPart variablename;
nonterminal inputs;
nonterminal outputs;
nonterminal bound;
nonterminal procedureCall;
nonterminal ScalarDecl parameter;
nonterminal conjunction;
nonterminal negation;
nonterminal compareExpn;
nonterminal arithExpn;
nonterminal term;
nonterminal factor;
nonterminal primary;
nonterminal ConstExpn constant;

// Non-terminals that have a value.
// nonterminal type nameList;

// PLEASE NOTE: your grammar can not use the 'precedence'
// feature of java-cup. The lines below should remain
// commented out.
//
//precedence left PLUS, MINUS;
//precedence left TIMES, DIVIDE;  // Higher precedence.
precedence  left ELSE;

// The grammar section.

// This specifies the initial symbol of the grammar.
start with program;

/* Notice that sometimes the action must be inside the production rule,
 * not after it. This is a subtle yet significant difference from YACC.
 * This is because the CUP parser is looking ahead one token. It ALWAYS
 * reads one more token before it will act on the production.
 */

program
  ::= scope  // the main program
      {:
        System.out.println("Program");
        RESULT = new Program();
      :}
;

scope
  ::= L_CURLEY declarations:dcs statements:stmts R_CURLEY  // scope with declarations and statements
      {:
        System.out.println("Scope");
        RESULT = new Scope();
        ((Scope)RESULT).setStatements(stmts);
        ((Scope)RESULT).setDeclarations(dcs);
      :}
    | L_CURLEY declarations:dcs R_CURLEY  // scope with declarations and statements
      {:
        System.out.println("Scope");
        RESULT = new Scope();
        ((Scope)RESULT).setDeclarations(dcs);
      :}
    | L_CURLEY statements:stmts R_CURLEY  // scope with statments only
      {:
        RESULT = new Scope();
        ((Scope)RESULT).setStatements(stmts);
      :}
    | L_CURLEY R_CURLEY  // empty scope
      {:
        RESULT = new Scope();
      :}
;

statements
  ::= statement:s  // sequence of statements
      {:
        RESULT = new ASTList<Stmt>();
        ((ASTList<Stmt>)RESULT).addLast(s);
      :}
    | statements:stmts statement:s
      {:
        RESULT = stmts;
        RESULT.addLast(s);
      :}
;

declarations
  ::= declaration:d  // sequence of declarations
      {:
        RESULT = new ASTList<Declaration>();
        ((ASTList<Declaration>)RESULT).addLast(d);
      :}
    | declarations:ds declaration:d
      {:
        RESULT = ds;
        RESULT.addLast(d);
      :}
;

statement
  ::= matchedStatement
    | unmatchedStatement
;

matchedStatement
  ::= variable COLON EQUAL expression  // assignment statement
    | IF expression THEN matchedStatement ELSE matchedStatement  // if statements
    | WHILE expression DO statement  // while statement
    | REPEAT statement UNTIL expression  // repeat statement
    | EXIT  // exit statements
    | EXIT INTCONST
    | EXIT WHEN expression
    | EXIT INTCONST WHEN expression
    | RETURN WITHX expression
    | RETURN  // return statements
    | WRITE outputs  // input/output statments
    | READ inputs
    | procedureCall  // procedure call
    | scope  // embedded scope
;

unmatchedStatement
  ::= IF expression THEN statement
    | IF expression THEN matchedStatement ELSE unmatchedStatement
;

procedureCall
  ::= IDENT  // call procedure with no parameters
    | IDENT L_PAREN arguments R_PAREN  // call procedure with parameters
;

declaration
  ::= VAR variablenames:varNames COLON type:t  // declare scalar/array variables
      {:
        System.out.println("Declaration");
        System.out.println(t.toString());

        // var a,b,c : Int
        RESULT = new MultiDeclarations();
        ((MultiDeclarations)RESULT).setElements(varNames);
        ((MultiDeclarations)RESULT).setType(t);
      :}
    | FUNCTION IDENT:fname COLON type:returnType scope:s // declare function
      {:
        System.out.println("Function Name: " + fname);

        RoutineBody body = new RoutineBody();
        body.setBody(s);

        RESULT = new RoutineDecl();
        ((RoutineDecl)RESULT).setName(fname);
        ((RoutineDecl)RESULT).setType(returnType);
        ((RoutineDecl)RESULT).setRoutineBody(body);
      :}
    | FUNCTION IDENT:fname L_PAREN parameters:params R_PAREN COLON type:returnType scope:s
      {:
        System.out.println("Function w/ args Name: " + fname);

        RoutineBody body = new RoutineBody();
        body.setBody(s);
        body.setParameters(params);

        RESULT = new RoutineDecl();
        ((RoutineDecl)RESULT).setName(fname);
        ((RoutineDecl)RESULT).setType(returnType);
        ((RoutineDecl)RESULT).setRoutineBody(body);
      :}
    | PROCEDURE IDENT:pname scope:s  // declare procedure
      {:
        System.out.println("Procedure Name: " + pname);

        RoutineBody body = new RoutineBody();
        body.setBody(s);

        RESULT = new RoutineDecl();
        ((RoutineDecl)RESULT).setName(pname);
        ((RoutineDecl)RESULT).setRoutineBody(body);
      :}
    | PROCEDURE IDENT:pname L_PAREN parameters:params R_PAREN scope:s
      {:
        System.out.println("Procedure w/ args Name: " + pname);

        RoutineBody body = new RoutineBody();
        body.setBody(s);
        body.setParameters(params);

        RESULT = new RoutineDecl();
        ((RoutineDecl)RESULT).setName(pname);
        ((RoutineDecl)RESULT).setRoutineBody(body);
      :}
;

variablenames
  ::= variablename:varName  // list of variables being declared
      {:
        System.out.println("VariableName");
        RESULT = new ASTList<DeclarationPart>();
        RESULT.addLast((DeclarationPart)varName);
      :}
    | variablenames:vs COMMA variablename:v
      {:
        System.out.println("VariableNames");
        RESULT = (ASTList<DeclarationPart>)vs;
        RESULT.addLast((DeclarationPart)v);
      :}
;

variablename
  ::= IDENT:id  // scalar variable
      {:
        System.out.println("VariableName: " + id);
        RESULT = new DeclarationPart();
        ((DeclarationPart)RESULT).setName(id);
      :}
    | IDENT L_SQUARE INTCONST R_SQUARE  // array variable with upper bound
    | IDENT L_SQUARE bound DOT DOT bound R_SQUARE  // array variable with upper/lower bounds
;

bound
  ::= INTCONST  // positive array bound
    | MINUS INTCONST  // negative array bound
;

type
  ::= INTEGER  // integer type
      {:
        RESULT = new IntegerType();
      :}
    | BOOLEAN  // boolean type
      {:
        RESULT = new BooleanType();
      :}
;

outputs
  ::= output  // list of output expressions
    | outputs COMMA output
;

output
  ::= expression  // integer expression
    | TEXTCONST  // text constant
    | NEWLINE  // newline constant
;

inputs
  ::= variable  // list of variables being read into
    | inputs COMMA variable
;

arguments
  ::= expression  // list of function/procedure arguments
    | arguments COMMA expression
;

parameters
  ::= parameter:param  // list of function/procedure formal parameters
      {:
        RESULT = new ASTList<ScalarDecl>();
        RESULT.addLast(param);
      :}
    | parameters:ps COMMA parameter:p
      {:
        RESULT = ps;
        RESULT.addLast(p);
      :}
;

parameter
  ::= IDENT:name COLON type:t  // declare one parameter
      {:
        RESULT = new ScalarDecl();
        ((ScalarDecl)RESULT).setName(name);
        ((ScalarDecl)RESULT).setType(t);
      :}
;

expression
  ::= conjunction  // disjunctions, associate left-to-right
    | expression OR conjunction
;

conjunction
  ::= negation  // conjunctions, associate left-to-right
    | conjunction AND negation
;

negation
  ::= compareExpn  // negations
    | NOT negation
;

compareExpn
  ::= arithExpn  // comparisons, do not associate
    | arithExpn EQUAL arithExpn
    |  arithExpn NOT EQUAL arithExpn
    | arithExpn LESS arithExpn
    | arithExpn LESS EQUAL arithExpn
    | arithExpn GREATER arithExpn
    | arithExpn GREATER EQUAL arithExpn
;

arithExpn
  ::= term  // expressions, associate + , - left-to-right
    | arithExpn PLUS term
    | arithExpn MINUS term
;

term
  ::= factor  // terms, associate * , /  left-to-right
    | term TIMES factor
    | term DIVIDE factor
;

factor
  ::= primary  // unary minus
    | MINUS factor
;

primary
  ::= constant  // integer or boolean constant
    | variable  // scalar, array variable or function call
    | IDENT L_PAREN arguments R_PAREN  // function call
    |  L_PAREN expression R_PAREN  // parenthesized expression
    | L_PAREN expression QUESTION expression COLON expression R_PAREN
;

constant // type: ConstEpn
  ::= INTCONST:i  // integer constant
      {:
        System.out.println("New Const :)");
        RESULT = new IntConstExpn();
        ((IntConstExpn)RESULT).setValue(i);
      :}
    | TRUE  // constant true
    | FALSE  // constant false
;

variable
  ::= IDENT  // scalar variable or function call
    | IDENT L_SQUARE expression R_SQUARE  // element of an array
;


